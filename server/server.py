# -*- coding: utf-8 -*-
"""chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13W9EyN3R7VzDcFwLd6xrmoAci4q6hUOq
"""
from flask import Flask
from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
import requests
import json
import pandas as pd
import re
import string
from fuzzywuzzy import fuzz
from fuzzywuzzy import process
import spacy
import pytextrank
from bson import json_util

import nltk
from nltk.corpus import stopwords

from nltk.stem import WordNetLemmatizer
from nltk.stem import LancasterStemmer
from nltk.stem import PorterStemmer


from pymongo import MongoClient
import json
cluster = MongoClient(
    "mongodb+srv://barun:baruns@cluster0.4qyqs6e.mongodb.net/?retryWrites=true&w=majority")

db = cluster["chatbot_database"]
collection = db["chatbot_dataset"]
symptoms_cursor = collection.find()
symptoms_data = list(symptoms_cursor)


# stopwords.words('english')

# removing double space
def remove_double_space(string):
    string = re.sub(' +', ' ', string)
    return string


# removing punctuations
PUNCT_TO_REMOVE = string.punctuation


def remove_punctuation(string):
    return string.translate(str.maketrans('', '', PUNCT_TO_REMOVE))

# remove stopwords


def remove_stopwords(text):
    ntext = ""
    for word in text.lower().split():
        if word.lower() not in stopwords.words('english'):
            ntext = ntext+" "+word
    return ntext

# lemitizer


def lemitize_words(text):
    lemmatizer = WordNetLemmatizer()
    ntext = ""
    for word in text.lower().split():
        ntext = ntext+" "+lemmatizer.lemmatize(word)
    return ntext


def preprocessing_text(text):
    text = str(text).lower()
    text = remove_double_space(text)
    text = remove_punctuation(text)
    text = re.sub('\n', '', text)
    text = re.sub('\w*\d\w*', '', text)
    text = lemitize_words(text)
    # text = remove_stopwords(text)
    return text

# with open('dataset.json') as json_file:
#     symptoms_data = json.load(json_file)


# print(type(symptoms_data))
symptoms = []
for dct in symptoms_data:
    symptoms.append(dct["symptom"])
# print(symptoms)


def symptom_questions(i):
    questions = []
    for dct in symptoms_data:
        if(dct["symptom"].lower() == i.lower()):
            for qu in dct["questions"]:
                questions.append(qu['ques'])
    return questions

# symptom_questions("cough")


def search_symptom(in_str):
    pp_in_str = preprocessing_text(in_str)
    in_symp = []
    phrase_model = spacy.load("en_core_web_sm")
    # add PyTextRank to the spaCy pipeline
    phrase_model.add_pipe("textrank")
    doc = phrase_model(pp_in_str)
    # examine the top-ranked phrases in the document
    for phrase in doc._.phrases:
        in_symp.append(str(phrase.text))
        # print(phrase.text)

    m_sym = []

    for inp in in_symp:
        for symp in symptoms:
            # print(symp.lower(), inp, fuzz.ratio(symp.lower(), inp))
            if fuzz.ratio(symp.lower(), inp) > 85:
                m_sym.append(symp)
    for ikw in in_str.split():
        for symp in symptoms:
            if fuzz.ratio(symp.lower(), ikw.lower()) > 85:
                if symp not in m_sym:
                    m_sym.append(symp)

    for symp in symptoms:
        if fuzz.ratio(symp.lower(), in_str.lower()) > 85:
            if symp not in m_sym:
                m_sym.append(symp)

    return m_sym


symptoms_data


def conditional_questions(in_symp, i, in_str):

    in_str = preprocessing_text(in_str)
    # print(type(in_str), in_str)

    for dct in symptoms_data:
        if(dct["symptom"].lower() == in_symp.lower()):
            if "condition" in dct["questions"][i].keys():
                # print(dct["questions"][i].keys())
                for cn in dct['questions'][i]['condition']:
                    if fuzz.ratio(cn, in_str) > 85:
                        return dct['questions'][i]['condition'][cn]
                        # print(dct['questions'][i]['condition'][cn])
    return []


app = Flask(__name__)
CORS(app)


@app.route('/')
def hello():
    return 'Hello, World!'


questions_asked = ["Kindly describe the symptoms you are experiencing?"]
responses = []
matched_symptoms = []
symptoms_done = []
quit = 1
init = 0
cur_symptom = 0
ques_no = 0
is_ques_con = 0
con_ques_no = 0
asking_con_ques = 0
con_ques = []
start = 0

is_personal_information = 0
personal_information_ques = ["Enter Name", "Age", "Gender"]
personal_information_responses = []
personal_info_ind = 1


@app.route('/api', methods=['POST'])
def api():
    global questions_asked
    global responses
    global matched_symptoms
    global symptoms_done
    global quit
    global init
    global cur_symptom
    global ques_no
    global is_ques_con
    global con_ques_no
    global asking_con_ques
    global con_ques
    global is_personal_information
    global personal_information_ques
    global personal_information_responses
    global personal_info_ind
    global start

    json = request.get_json()
    user_input = json.get('input')

    if start == 0 and user_input != '/start':
        response = jsonify(output="Type '/start' to start the conversation")
        return response

    if user_input == '/start':
        start = 1

        questions_asked = [
            "Kindly describe the symptoms you are experiencing?"]
        responses = []
        matched_symptoms = []
        symptoms_done = []
        quit = 1
        init = 0
        cur_symptom = 0
        ques_no = 0
        is_ques_con = 0
        con_ques_no = 0
        asking_con_ques = 0
        con_ques = []
        is_personal_information = 0
        personal_information_responses = []
        personal_info_ind = 1

        response = jsonify(output=personal_information_ques[0])
        return response

    if user_input == "quit":
        questions_asked = [
            "Kindly describe the symptoms you are experiencing?"]
        responses = []
        matched_symptoms = []
        symptoms_done = []
        quit = 1
        init = 0
        cur_symptom = 0
        ques_no = 0
        is_ques_con = 0
        con_ques_no = 0
        asking_con_ques = 0
        con_ques = []
        is_personal_information = 0
        personal_information_responses = []
        personal_info_ind = 1
        start = 0
        response = jsonify(output="Thank You")
        return response

    if is_personal_information == 0:
        personal_information_responses.append(user_input)
        qu = personal_information_ques[personal_info_ind]
        personal_info_ind += 1
        # print(qu)
        if personal_info_ind == len(personal_information_ques):
            is_personal_information = 1
            personal_info_ind = 1
            # print(personal_information_ques)
            # print(personal_information_responses)

        response = jsonify({"output": qu})
        return response

    if is_personal_information == 1:
        is_personal_information = 2
        personal_information_responses.append(user_input)
        qu = questions_asked[0]
        response = jsonify({"output": qu})
        return response

    m_sym = search_symptom(user_input)
    for sy in search_symptom(user_input):
        if sy not in matched_symptoms:
            matched_symptoms.append(sy)

    if init == 0:
        if len(m_sym) == 0:
            if len(matched_symptoms) == 0:
                matched_symptoms.append("general_questions")
        else:
            for sy in search_symptom(user_input):
                if sy not in matched_symptoms:
                    matched_symptoms.append(sy)
        # print(matched_symptoms)
        init = 1

    if init != 0 and is_personal_information == 2:
        responses.append(user_input)

    if cur_symptom == len(matched_symptoms) and asking_con_ques == 0 and init != 4:
        init = 4
        response = jsonify({"output": "Any other symptoms?"})
        return response

    if cur_symptom == len(matched_symptoms) and asking_con_ques == 0 and init == 4:
        # print(questions_asked)
        # print(responses)
        ques_res_col = db["ques_res"]
        q_r_l = min(len(questions_asked), len(responses))
        q_r_d = []
        personal_info = []
        for i in range(len(personal_information_responses)):
            cd = {"question": personal_information_ques[i],
                  "response": personal_information_responses[i]}
            personal_info.append(cd)

        for i in range(q_r_l):
            cd = {"question": questions_asked[i], "response": responses[i]}
            q_r_d.append(cd)

        ques_res_col.insert_one(
            {"personal_info": personal_info, "questions_responses": q_r_d})
        questions_asked = [
            "Kindly describe the symptoms you are experiencing?"]
        responses = []
        matched_symptoms = []
        symptoms_done = []
        quit = 1
        init = 0
        cur_symptom = 0
        ques_no = 0
        is_ques_con = 0
        con_ques_no = 0
        asking_con_ques = 0
        con_ques = []
        is_personal_information = 0
        personal_information_responses = []
        personal_info_ind = 1
        start = 0
        response = jsonify(output="Thank You! Your responses are recorded.")
        return response

    i = matched_symptoms[cur_symptom]
    dct = {}
    for d in symptoms_data:
        if(d["symptom"].lower() == i.lower()):
            dct = d
            break

    if init == 1:
        ques = symptom_questions(i)
        qu = ques[ques_no]
        questions_asked.append(qu)
        ques_no = ques_no + 1
        init = 2
        response = jsonify(output=qu)
        return response

    if asking_con_ques == 0:
        con_ques = conditional_questions(i, ques_no-1, user_input)
        # print(con_ques)
        # print(len(con_ques))
        if (len(con_ques) > 0):
            is_ques_con = 1
            con_ques_no = 0
            asking_con_ques = 1

    if asking_con_ques == 2:
        asking_con_ques = 0

    if is_ques_con == 1:
        list_con_ques = con_ques
        # print(list_con_ques)
        qu = list_con_ques[con_ques_no]
        con_ques_no += 1
        # print(qu)
        if con_ques_no == len(list_con_ques):
            is_ques_con = 0
            con_ques_no = 0
            asking_con_ques = 2
        response = jsonify({"output": qu})
        return response

    else:
        ques = symptom_questions(i)
        qu = ques[ques_no]
        # print(qu)
        questions_asked.append(qu)
        ques_no = ques_no + 1

        if ques_no == len(dct["questions"]):
            cur_symptom = cur_symptom+1
            ques_no = 0
            symptoms_done.append(i)
        response = jsonify(output=qu)
        return response


@app.route('/fetchallresponses', methods=['GET'])
def fetchallresponses():
    q_r_collection = db["ques_res"]
    docs_list = list(q_r_collection.find())
    docs_list.reverse()
    return json.dumps(docs_list, default=json_util.default)


# Running the app
if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5001, debug=True)
